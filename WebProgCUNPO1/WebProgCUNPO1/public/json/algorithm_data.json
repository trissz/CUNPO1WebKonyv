{
    "algorithms": [
        {
            "id": 0,
            "code_id": 0,
            "name": "Lineáris keresés",
            "category": "Kereső algoritmus",
            "description": "A lineáris keresés egy egyszerű keresési algoritmus, ahol N elem közül kiválasztunk egy meghatározott elemet.",
            "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    //Lineáris keresés\n\n    setlocale(LC_ALL,\"\");\n\n    int n = 10, cel_elem = -4;\n\n    int tomb[n] = {2, -21, 6, 3, 65, 89, 38, -4, -77, 100};\n\n    for ( int i = 0; i < n; i ++ )\n    {\n        if ( tomb[i] == cel_elem )\n        {\n            cout << \"A keresendő elem (\" << cel_elem << \") a(z) \" << i << \". helyen található az adatszerkezetben.\";\n        }\n    }\n\n    return 0;\n}\n",
            "runtime": "O(N)",
            "detailed_information": "A lineáris keresés egy alapvető keresési algoritmus, amelyet gyakran alkalmaznak az adatstruktúrákban, például tömbökben vagy listákban.<br>Az algoritmus célja egy adott érték megtalálása egy adatszerkezetben.<br>A lineáris keresés egyszerű és könnyen megvalósítható algoritmus, bár az időigénye nagy adatmennyiségek esetén növekedhet.<br>Ezért fontos megfontolni az alkalmazását az adott feladathoz és az adatmérethez képest."
        },
        {
            "id": 1,
            "code_id": 1,
            "name": "Bináris keresés",
            "category": "Kereső algoritmus",
            "description": "A bináris keresés egy gyors és hatékony kereső algoritmus, mely egy úgynevezett intervallum felezési módszerrel találja meg a keresett elemet.",
            "code": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nconst int target_number = 65434;\n\nint main()\n{\n    //Bináris keresés\n\n    setlocale(LC_ALL,\\”\\”);\n\n    int tomb[10] = {-100, 1, 6, 8, 9, 17, 45, 63, 102, 200};\n\n    int cel_szam = -100;\n    int bal = 0;\n    int jobb = 10;\n    int kozep = ( bal + jobb ) / 2;\n    int index;\n    int lepesek_szama = 1;\n\n    while ( true )\n    {\n        index = ( bal + jobb ) / 2;\n\n        if ( tomb[index] < cel_szam )\n        {\n            bal = index;\n        }\n\n        if ( tomb[index] > cel_szam )\n        {\n            jobb = index;\n        }\n\n        if ( tomb[index] == cel_szam )\n        {\n            cout << \"A keresett index: \" << index << endl;\n\n            break;\n        }\n\n        lepesek_szama ++;\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n",
            "runtime": "O(log(N))",
            "detailed_information": "A bináris keresés egy hatékony keresési algoritmus, amelyet rendezett adatsorok vagy tömbök keresésére alkalmazunk. Ez az algoritmus a gyors és hatékony keresés egyik legismertebb formája, mivel a keresett adatsor méretétől függetlenül gyorsan megtalálja a keresett elemet vagy jelez, ha az nem található."
        },
        {
            "id": 2,
            "code_id": 2,
            "name": "Buborék rendezés",
            "category": "Rendező algoritmus",
            "description": "A buborék rendező algoritmus tekinthető a legegyszerűbb rendezési algoritmusnak, mely elempárok összehasonlítása alapján végzi el a rendezést.",
            "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    //Buborék rendezés\n\n    setlocale(LC_ALL,\"\");\n    \n    int tomb[5] = {64, 25, 12, 22, 11};\n    \n    for ( int i = 0; i < 5 - 1; i ++ )\n    {\n        for ( int j = 0; j < 5 - i - 1; j ++ )\n        {\n            if ( tomb[j] > tomb[j + 1] )\n            {\n                int ideiglenes = tomb[j];\n                tomb[j] = tomb[j + 1];\n                tomb[j + 1] = ideiglenes;\n            }\n        }\n    }\n    \n    //Rendezett adatok kiíratása\n    \n    cout << \"Rendezett adatok: \";\n    \n    for ( int i = 0; i < 5; i ++ )\n    {\n        cout << tomb[i] << \" \";\n    }\n    \n    cout << endl;\n    \n    return 0;\n}\n",
            "runtime": "O(N<sup>2</sup>)",
            "detailed_information": "A buborék rendezés egy egyszerű, de hatékony algoritmus, amelyet arra használunk, hogy rendezzük egy adatsor vagy tömb elemeit növekvő vagy csökkenő sorrendbe. Ez az algoritmus az egymás melletti elemeket hasonlítja össze és cseréli fel, amíg az összes elem a megfelelő helyre nem kerül."
        },
        {
            "id": 3,
            "code_id": 3,
            "name": "Kiválasztásos rendezés",
            "category": "Rendező algoritmus",
            "description": "A kiválasztásos rendező algoritmus egy egyszerű, főleg oktatásban használt algoritmus, mely gyakorlatilag minden iterációban kiválasztja a következő minimum elemet egy adott reláció alapján.",
            "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    //Kiválasztásos rendezés\n\n    setlocale(LC_ALL,\"\");\n    \n    int tomb[7] = {-56, 128, 22, 55, -53, 11, 98};\n    \n    for ( int i = 0; i < 7 - 1; i ++ )\n    {\n        for ( int j = i + 1; j < 7; j ++ )\n        {\n            if ( tomb[j] < tomb[i] )\n            {\n                int ideiglenes = tomb[j];\n                tomb[j] = tomb[i];\n                tomb[i] = ideiglenes;\n            }\n        }\n    }\n    \n    //Rendezett adatok kiíratása\n    \n    cout << \"Rendezett adatok: \";\n    \n    for ( int i = 0; i < 7; i ++ )\n    {\n        cout << tomb[i] << \" \";\n    }\n    \n    cout << endl;\n    \n    return 0;\n}\n",
            "runtime": "O(N<sup>2</sup>)",
            "detailed_information": "A kiválasztásos rendezés egy egyszerű rendezési algoritmus, amely során az adatszerkezet rendezése úgy történik, hogy minden lépésben a legkisebb (vagy legnagyobb) elem kerül a megfelelő pozícióba.\nKülönösen kisebb méretű adatszerkezetek esetén teljesít versenyképesen, ám nagyobb adatszerkezetek rendezésére általában hatékonyabb algoritmusokat alkalmaznak a magasabb teljesítmény és az időigény csökkentése érdekében."
        },
        {
            "id": 4,
            "code_id": 4,
            "name": "Kiválasztás",
            "category": "Kiválasztási algoritmus",
            "description": "A kiválasztás algoritmus egy elemhalmazból kiválasztja azokat az elemeket, melyek megfelelnek egy meghatározott kritériumnak (vagy T tulajdonságnak), majd visszaadja ezen elemek listáját.",
            "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    //Kiválasztás\n    \n    //T tulajdonság: az adat kisebb, mint 0\n    \n    setlocale(LC_ALL,\"\");\n    \n    int tomb[10] = {-98, 432, 2, 546, -48, -68, 98, 333, 642, -44};\n    \n    for ( int i = 0; i < 10; i ++ )\n    {\n        if ( tomb[i] < 0 ) //Feltétel\n        {\n            cout << tomb[i] << \" \";\n        }\n    }\n    \n    return 0;\n}\n",
            "runtime": "O(K) - O(N)",
            "detailed_information": "A kiválasztási algoritmus olyan keresési algoritmus, amelynek célja, hogy megtalálja az adott adatszerkezetben azokat az elemeket, amelyek kielégítenek egy adott feltételt (T tulajdonság), és ezeket egy listában vagy más struktúrában visszaadja.\nAz algoritmus egyszerű, és könnyen alkalmazható a kívánt elemek megtalálására."
        },
        {
            "id": 5,
            "code_id": 5,
            "name": "K-középértékek",
            "category": "Csoportosítási (klaszterező) algoritmus",
            "description": "A K-középértékek algoritmus megadott adatokat csoportosít úgy, hogy azok és az úgynevezett <i>centroid</i> pontok közötti távolságot minimalizálja, leggyakrabban geometriai értelmezésben.",
            "code": "//K-középérték\n\nlet width, height;\nconst defaultFill = \"black\", bgColor = \"white\";\nconst defaultDataPointColor = \"black\", defaultCentroidColor = \"yellow\", defaultLineColor = \"black\";\nconst defaultDataPointRadius = 12, defaultCentroidRadius = 17;\nconst paddingX = 20, paddingY = 20;\nlet numberOfDataPoints = 2000, numberOfCentroids = 50, minX = 0 + paddingX, maxX, minY = 0 + paddingY, maxY;\nlet dataPoints = [], centroids = [], colors = [];\nlet globalCentroidId = 0;\nlet frameSpeed = 10;\nlet drawLines = true;\n\nfunction DataPoint(x, y)\n{\n  this.x = Number(x);\n  this.y = Number(y);\n  this.r = defaultDataPointRadius;\n  this.color = [];\n  this.groupId = null;\n}\n\nfunction Centroid(id, x, y, color)\n{\n  this.id = id;\n  this.x = Number(x);\n  this.y = Number(y);\n  this.r = defaultCentroidRadius;\n  this.color = color;\n}\n\nfunction setup()\n{\n  width = windowWidth;\n  height = windowHeight;\n  maxX = width - paddingX;\n  maxY = height - paddingY;\n  createCanvas(width, height);\n  generateRandomDataPoints(numberOfDataPoints, minX, maxX, minY, maxY);\n  generateRandomColors(numberOfCentroids);\n  generateCentroids(numberOfCentroids, minX, maxX, minY, maxY);\n  noStroke();\n  background(bgColor);\n  drawDataPoints();\n  drawCentroids();\n  frameRate(frameSpeed);\n}\n\nfunction draw()\n{\n  background(bgColor);\n  performClustering();\n  calculateNewMean();\n\n  if ( drawLines )\n  {\n    drawConnectionLines();\n  }\n\n  drawDataPoints();\n  drawCentroids();\n}\n\nfunction distance(P1, P2)\n{\n  return Number(Math.sqrt(Math.pow(P1.x - P2.x, 2) + Math.pow(P1.y - P2.y, 2)));\n}\n\nfunction generateRandomDataPoints(n, fromX, toX, fromY, toY)\n{\n  for ( let i = 0; i < n; i ++ )\n  {\n    dataPoints.push(new DataPoint(random(fromX, toX), random(fromY, toY)));\n  }\n}\n\nfunction drawDataPoints()\n{\n  fill(defaultDataPointColor);\n\n  for ( let i = 0; i < dataPoints.length; i ++ )\n  {\n    if ( dataPoints[i].groupId != null )\n    {\n      fill(centroids[dataPoints[i].groupId].color[0], centroids[dataPoints[i].groupId].color[1], centroids[dataPoints[i].groupId].color[2], 255); //centroids[dataPoints[i].groupId].color[3]\n    }\n\n    circle(dataPoints[i].x, dataPoints[i].y, dataPoints[i].r);\n\n    fill(defaultDataPointColor);\n  }\n\n  fill(defaultFill);\n}\n\nfunction generateCentroids(n, fromX, toX, fromY, toY)\n{\n  for ( let i = 0; i < n; i ++ )\n  {\n    centroids.push(new Centroid(globalCentroidId++, random(fromX, toX), random(fromY, toY), colors[globalCentroidId - 1]));\n  }\n}\n\nfunction drawCentroids()\n{\n  for ( let i = 0; i < centroids.length; i ++ )\n  {\n    fill(centroids[i].color);\n\n    //circle(centroids[i].x, centroids[i].y, centroids[i].r);\n    rect(centroids[i].x - ( centroids[i].r / 2 ), centroids[i].y - ( centroids[i].r / 2 ), centroids[i].r, centroids[i].r);\n  }\n\n  fill(defaultFill);\n}\n\nfunction performClustering()\n{\n  for ( let i = 0; i < dataPoints.length; i ++ )\n  {\n    let closestId = centroids[0].id, minDistance = distance(dataPoints[i], centroids[0]);\n\n    for ( let j = 1; j < centroids.length; j ++ )\n    {\n      if ( minDistance > distance(dataPoints[i], centroids[j]) )\n      {\n        closestId = centroids[j].id;\n        minDistance = distance(dataPoints[i], centroids[j]);\n      }\n    }\n\n    dataPoints[i].groupId = closestId;\n  }\n}\n\nfunction calculateNewMean()\n{\n  for ( let i = 0; i < centroids.length; i ++ )\n  {\n    let sumX = 0, sumY = 0, k = 0;\n\n    for ( let j = 0; j < dataPoints.length; j ++ )\n    {\n      if ( dataPoints[j].groupId === centroids[i].id )\n      {\n        sumX += dataPoints[j].x;\n        sumY += dataPoints[j].y;\n        k ++;\n      }\n    }\n\n    if ( k != 0 )\n    {\n      centroids[i].x = sumX / k;\n      centroids[i].y = sumY / k;\n    }\n  }\n}\n\nfunction generateRandomColors(n)\n{\n  for ( let i = 0; i < n; i ++ )\n  {\n    colors.push([random(255), random(255), random(255), 255]); //random(255)\n  }\n}\n\nfunction drawConnectionLines()\n{\n  stroke(defaultLineColor);\n  strokeWeight(0.5);\n\n  for ( let i = 0; i < dataPoints.length; i ++ )\n  {\n    if ( dataPoints[i].groupId != null )\n    {\n      line(dataPoints[i].x, dataPoints[i].y, centroids[dataPoints[i].groupId].x, centroids[dataPoints[i].groupId].y);\n    }\n  }\n\n  noStroke();\n}\n\n",
            "runtime": "O(n×k×i×d)",
            "detailed_information": "A K-középérték (K-means) egy népszerű csoportosítási algoritmus, amely célja az adatok csoportosítása K klaszterbe úgy, hogy minden adatpont a legközelebbi középponthoz tartozzon.\nA K-középérték algoritmust gyakran használják a csoportosításra, mint például a piackutatásban, a képfeldolgozásban, az adatbányászatban és más területeken, ahol az adatok csoportosítása fontos feladat.\nFontos megjegyezni, hogy a K-középérték algoritmus az inicializációra érzékeny lehet, és a véletlenszerűen választott középpontokhoz való konvergencia nem garantált. "
        },
        {
            "id": 6,
            "code_id": 6,
            "name": "Bináris fabejárás",
            "category": "Gráf algoritmus",
            "description": "A Bináris fabejárás algoritmus egy fa szerkezetű adatstruktúra bejárását végzi el, ahol minden csomópontot pontosan egyszer látogat meg. A bejárás során a csomópontokat gyakran balról jobbra vagy fordítva látogatja meg, majd felfelé vagy lefelé halad a fa hierarchiájában.",
            "code": "#include <iostream>\n\nusing namespace std;\n\nstruct Csomopont\n{\n    int adat;\n    Csomopont* bal;\n    Csomopont* jobb;\n\n    Csomopont(int adat)\n    {\n        this->adat = adat;\n        bal = nullptr;\n        jobb = nullptr;\n    }\n};\n\nvoid beszur(Csomopont*& gyoker, int adat)\n{\n    if ( gyoker == nullptr )\n    {\n        gyoker = new Csomopont(adat);\n        return;\n    }\n\n    if ( adat < gyoker->adat )\n    {\n        beszur(gyoker->bal, adat);\n    }\n    else\n    {\n        beszur(gyoker->jobb, adat);\n    }\n}\n\nvoid inorderBejaras(Csomopont* gyoker)\n{\n    if ( gyoker == nullptr ) return;\n\n    inorderBejaras(gyoker->bal);\n    cout << gyoker->adat << \" \";\n    inorderBejaras(gyoker->jobb);\n}\n\nint main()\n{\n    //Bináris fabejárás\n\nCsomopont* gyoker = nullptr;\n\n    //Elemek beszúrása a fába\n    \n    beszur(gyoker, 10);\n    beszur(gyoker, 5);\n    beszur(gyoker, 15);\n    beszur(gyoker, 3);\n    beszur(gyoker, 7);\n    beszur(gyoker, 12);\n    beszur(gyoker, 20);\n\n    //Inorder bejárás (részfa rendezett elemeket eredményez)\n    \n    cout << \"Inorder bejárás eredménye: \";\n    inorderBejaras(gyoker);\n    cout << endl;\n\n    return 0;\n}\n",
            "runtime": "O(N)",
            "detailed_information": "A bináris fabejárás egy olyan algoritmus, amely célja egy bináris fa összes csomópontjának megtekintése vagy feldolgozása.\nA bináris fa egy olyan adatszerkezet, amelyben minden csomópontnak legfeljebb két gyereke lehet: egy bal és egy jobb gyermek.\nA bináris fabejárás gyakran alkalmazzák faalapú adatszerkezetek, például bináris keresőfák, kifejezésfák, vagy Huffman kódolású fák bejárására.\nKülönböző bejárás típusok alkalmazása lehetővé teszi különböző feladatok végrehajtását a fa csomópontjain, és számos alkalmazási területen hasznos lehet."
        },
        {
            "id": 7,
            "code_id": 7,
            "name": "N-ágú fabejárás",
            "category": "Gráf algoritmus",
            "description": "Az N-ágú fabejárás algoritmus egy fa szerkezetű adatstruktúra bejárását végzi el, ahol minden csomópontot pontosan egyszer látogat meg. A csomópontok bejárásának sorrendje nincs meghatározva.",
            "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Csomopont\n{\n    int adat;\n    vector<Csomopont*> gyerekek;\n\n    Csomopont(int adat)\n    {\n        this->adat = adat;\n    }\n};\n\nvoid beszur(Csomopont*& gyoker, int adat)\n{\n    if ( gyoker == nullptr )\n    {\n        gyoker = new Csomopont(adat);\n        return;\n    }\n\n    // Felhasználó által megadott számú gyerekkel rendelkező fa esetén\n    \n    for (auto& gyerek : gyoker->gyerekek)\n    {\n        if (gyerek->adat < adat) {\n            beszur(gyerek, adat);\n            return;\n        }\n    }\n\n    // Ha az összes gyerek nagyobb, akkor új gyereket hozunk létre\n    \n    gyoker->gyerekek.push_back(new Csomopont(adat));\n}\n\nvoid inorderBejaras(Csomopont* gyoker)\n{\n    if ( gyoker == nullptr ) return;\n\n    for ( auto& gyerek : gyoker->gyerekek )\n    {\n        inorderBejaras(gyerek);\n        cout << gyerek->adat << \" \";\n    }\n}\n\nint main()\n{\n    //N-ágú fabejárás\n    \n    Csomopont* gyoker = nullptr;\n\n    //Elemek beszúrása a fába\n    \n    beszur(gyoker, 10);\n    beszur(gyoker, 5);\n    beszur(gyoker, 15);\n    beszur(gyoker, 3);\n    beszur(gyoker, 7);\n    beszur(gyoker, 12);\n    beszur(gyoker, 20);\n\n    //Inorder bejárás (részfa rendezett elemeket eredményez)\n    \n    cout << \"Inorder bejárás eredménye: \";\n    inorderBejaras(gyoker);\n    cout << endl;\n\n    return 0;\n}\n",
            "runtime": "O(N)",
            "detailed_information": "Az N-agú fabejárás (vagy általános fabejárás) egy olyan algoritmus, amely egy tetszőleges N-agú fát jár be, vagyis olyan fát, ahol egy csomópontnak lehet N meghatározatlan gyermekcsomópontja.\nAz algoritmus célja a fa összes csomópontjának megtekintése vagy feldolgozása.\nÚgy működik, hogy minden csomópontot meglátogat, majd rekurzívan végigmegy az összes gyermekén.\nAz N-agú fabejárás egy hatékony és rugalmas módja a tetszőleges méretű és formájú fák bejárásának.\nAz algoritmus lehetővé teszi a fa csomópontjainak hatékony feldolgozását és elemzését, és számos alkalmazási területen hasznos lehet."
        },
        {
            "id": 8,
            "code_id": 8,
            "name": "Elárasztásos kitöltés",
            "category": "Gráf algoritmus",
            "description": "Az elárasztásos kitöltés (floodfill), egy algoritmus, amely meghatározza az adott csomóponthoz kapcsolódó területet egy többdimenziós tömbben.",
            "code": "#include<iostream> \n\nusing namespace std; \n\n#define M 8\n#define N 8\n\nvoid floodFill(int kijelzo[][N], int x, int y, int aktualisSzin, int ujSzin)\n{ \n    if ( x < 0 || x >= M || y < 0 || y >= N ) return; \n    if ( kijelzo[x][y] != aktualisSzin ) return; \n    if ( kijelzo[x][y] == ujSzin ) return; \n  \n    kijelzo[x][y] = ujSzin; \n  \n    floodFill(kijelzo, x + 1, y, aktualisSzin, ujSzin); \n    floodFill(kijelzo, x - 1, y, aktualisSzin, ujSzin); \n    floodFill(kijelzo, x, y + 1, aktualisSzin, ujSzin); \n    floodFill(kijelzo, x, y - 1, aktualisSzin, ujSzin); \n} \n\nvoid szinMegtalalasa(int kijelzo[][N], int x, int y, int ujSzin) \n{ \n    int aktualisSzin = kijelzo[x][y]; \n    floodFill(kijelzo, x, y, aktualisSzin, ujSzin); \n} \n  \nint main() \n{ \n//Elárasztásos kitöltés\n\n    int kijelzo[M][N] = \n                    {\n                      {3, 2, 1, 1, 1, 1, 1, 1}, \n                      {1, 1, 1, 1, 1, 1, 0, 0}, \n                      {1, 0, 0, 1, 1, 0, 1, 1}, \n                      {1, 2, 2, 2, 2, 0, 1, 0}, \n                      {1, 1, 1, 2, 2, 0, 1, 0}, \n                      {1, 1, 1, 2, 2, 2, 2, 0}, \n                      {1, 1, 1, 1, 1, 2, 1, 1}, \n                      {1, 1, 1, 1, 1, 2, 2, 1}, \n                     }; \n                     \n    int x = 4, y = 4, ujSzin = 3; \n    \n    szinMegtalalasa(kijelzo, x, y, ujSzin); \n  \n    cout << \"A kijelző frissítve: \n\"; \n    \n    for ( int i = 0; i < M; i ++ ) \n    { \n        for ( int j = 0; j < N; j ++ ) \n        {\n            cout << kijelzo[i][j] << \" \"; \n        }\n        \n        cout << endl; \n    } \n    \n    return 0;\n}\n",
            "runtime": "O(N<sup>2</sup>)",
            "detailed_information": "Az Elárasztásos kitöltés (flood fill) egy algoritmus, amely egy adott kiinduló pontból kiindulva kitölti vagy színezi a hozzá tartozó területet egy képen vagy egy adatszerkezetben.\nAz elárasztásos kitöltés tipikusan két dimenziós rácsokon (például képek) alkalmazható, és használható például képekben lévő zárt területek bejelölésére vagy színezésére.\nFontos megérteni, hogy az elárasztásos kitöltés hatékony módszer lehet, de figyelembe kell venni az algoritmus határterületeit és esetleges korlátait, például a memóriahasználatot vagy a pontosságot.\nAz algoritmus egyszerűsége és hatékonysága miatt széles körben alkalmazzák képfeldolgozásban és grafikus alkalmazásokban."
        },
        {
            "id": 9,
            "code_id": 9,
            "name": "A*",
            "category": "Gráf algoritmus",
            "description": "Az A* algoritmus egy rendkívül hatékony útvonalkereső algoritmus, mely két megadott pont között megkeresi a legrövidebb útvonalat. Az algoritmus heurisztikát használ.",
            "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <windows.h>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst short rows = 31; ///Input 1: 50 ///Input 2: 13 ///Input 3: 31\nconst short columns = 64; ///Input 1: 50 ///Input 2: 19 ///Input 3: 64\nconst float distance_between_tiles = 1.0;\nconst char object_character = '#'; ///Input 1: '#'\nconst char output_object_character = char(4);\nconst short output_setw_value = 2;\nconst short output_start_color = 100;\nconst short output_goal_color = 200;\nconst short output_object_color = 64;\nconst short output_road_color = 22;\nconst short output_space_color = 230;\n\nstruct coordinate\n{\n    int row;\n    int column;\n};\n\nstruct grid_data\n{\n    coordinate point;\n    coordinate parent = {0, 0};\n    float local_score = INFINITY;\n    float global_score = INFINITY;\n    bool object;\n};\n\nvoid OutputGrid( grid_data grid_in[rows][columns] );\nbool IsValidCoordinate( coordinate point_in );\nfloat HeuristicDistance( int row_1, int column_1, int row_2, int column_2 );\nbool CheckIfSolvable( grid_data grid[rows][columns], coordinate base_point, coordinate goal_point );\nvoid A_star( grid_data grid[rows][columns], coordinate start, coordinate goal );\n\nset <pair <int, int>> object_point_set;\n\nint main()\n{\n    setlocale(LC_ALL,\"\");\n\n    SendMessage(GetConsoleWindow(), WM_SYSKEYDOWN, VK_RETURN, 0x20000000); //For fullscreen\n\n    grid_data initial_grid[rows][columns];\n\n    ifstream fin;\n\n    string line;\n\n    fin.open(\"input_grid_3.txt\"); ///Input 1: input_grid.txt ///Input 2: input_grid_2.txt ///Input 3: input_grid_3.txt\n\n    for ( int i = 0; i < rows; i ++ )\n    {\n        getline(fin, line);\n\n        for ( int j = 0; j < columns; j ++ )\n        {\n            initial_grid[i][j].point = {i, j};\n\n            if ( line[j] == '|' || line[j] == '+' || line[j] == '-' ) ///Input 1: line[j] == object_character ///Input 2: line[j] == '|' || line[j] == ':' || line[j] == '-' || line[j] == '.' ///Input 3: line[j] == '|' || line[j] == '+' || line[j] == '-'\n            {\n                initial_grid[i][j].object = true;\n                object_point_set.insert(make_pair(i, j));\n            }else initial_grid[i][j].object = false;\n        }\n    }fin.close();\n\n    //OutputGrid(initial_grid);\n\n    coordinate initial_start;\n    coordinate initial_goal;\n\n    initial_start.row = 29; ///Input 1: 0 ///Input 2: 0 ///Input 3: 29\n    initial_start.column = 0; ///Input 1: 0 ///Input 2: 11 ///Input 3: 0\n    initial_goal.row = 29; ///Input 1: 15 ///Input 2: 12 ///Input 3: 29\n    initial_goal.column = 63; ///Input 1: 23 ///Input 2: 1 ///Input 3: 63\n\n    bool can_perform = true;\n\n    if ( object_point_set.find(make_pair(initial_start.row, initial_start.column)) != object_point_set.end() )\n    {\n        cout << \"The given starting point is an object ! The algorithm can not be performed . . .\n\n\";\n\n        can_perform = false;\n    }\n\n    if ( object_point_set.find(make_pair(initial_goal.row, initial_goal.column)) != object_point_set.end() )\n    {\n        cout << \"The given starting point is an object ! The algorithm can not be performed . . .\n\n\";\n\n        can_perform = false;\n    }\n\n    if ( !CheckIfSolvable(initial_grid, initial_start, initial_goal) )\n    {\n        cout << \"The given grid maze is not solvable ! The algorithm can not be performed . . .\n\n\";\n\n        can_perform = false;\n    }\n\n    if ( can_perform )\n    {\n        A_star(initial_grid, initial_start, initial_goal);\n    }\n\n    system(\"pause\");\n\n    return 0;\n}\n\nvoid OutputGrid( grid_data grid_in[rows][columns] )\n{\n    cout <<  \"\n\n-----Output grid-----\n\n\";\n\n    for ( int i = 0; i < rows; i ++ )\n    {\n        for ( int j = 0; j < columns; j ++ )\n        {\n            cout << setw(5) << grid_in[i][j].local_score << \" \";\n            //cout << setw(5) << grid_in[i][j].parent.row << \", \" << grid_in[i][j].parent.column << \" \";\n        }\n\n        cout << endl;\n    }\n\n    cout <<  \"\n\n--------------------------------------------------------------------------------\n\n\";\n}\n\nbool IsValidCoordinate( coordinate point_in )\n{\n    return ( point_in.row >= 0 && point_in.column >= 0 && point_in.row < rows && point_in.column < columns && object_point_set.find(make_pair(point_in.row, point_in.column)) == object_point_set.end() );\n}\n\nfloat HeuristicDistance( int row_1, int column_1, int row_2, int column_2 )\n{\n    return ( sqrt(pow(row_1 - row_2, 2) + pow(column_1 - column_2, 2)) );\n}\n\nbool CheckIfSolvable( grid_data grid[rows][columns], coordinate base_point, coordinate goal_point )\n{\n    vector <coordinate> q;\n    set <pair <int, int>> visited;\n\n    q.push_back(base_point);\n    visited.insert(make_pair(base_point.row, base_point.column));\n\n    while ( !q.empty() )\n    {\n        if ( IsValidCoordinate({q[0].row - 1, q[0].column}) && visited.find(make_pair(q[0].row - 1, q[0].column)) == visited.end() )\n        {\n            q.push_back({q[0].row - 1, q[0].column});\n            visited.insert(make_pair(q[0].row - 1, q[0].column));\n        }\n\n        if ( IsValidCoordinate({q[0].row + 1, q[0].column}) && visited.find(make_pair(q[0].row + 1, q[0].column)) == visited.end() )\n        {\n            q.push_back({q[0].row + 1, q[0].column});\n            visited.insert(make_pair(q[0].row + 1, q[0].column));\n        }\n\n        if ( IsValidCoordinate({q[0].row, q[0].column - 1}) && visited.find(make_pair(q[0].row, q[0].column - 1)) == visited.end() )\n        {\n            q.push_back({q[0].row, q[0].column - 1});\n            visited.insert(make_pair(q[0].row, q[0].column - 1));\n        }\n\n        if ( IsValidCoordinate({q[0].row, q[0].column + 1}) && visited.find(make_pair(q[0].row, q[0].column + 1)) == visited.end() )\n        {\n            q.push_back({q[0].row, q[0].column + 1});\n            visited.insert(make_pair(q[0].row, q[0].column + 1));\n        }\n\n        q.erase(q.begin());\n    }\n\n    return ( visited.find(make_pair(goal_point.row, goal_point.column)) != visited.end() );\n}\n\nvoid A_star( grid_data grid[rows][columns], coordinate start, coordinate goal )\n{\n    grid[start.row][start.column].local_score = 0;\n    grid[start.row][start.column].global_score = 0;\n    grid[start.row][start.column].parent = {0,0};\n\n    vector <coordinate> point_queue;\n    set <pair <int, int>> point_set;\n\n    point_queue.push_back(start);\n    point_set.insert(make_pair(start.row, start.column));\n\n    while ( !point_queue.empty() /*&& point_set.find(make_pair(goal.row, goal.column)) == point_set.end()*/ )\n    {\n        //cout << point_queue.size() << \" | \" << point_queue[0].row << \", \" << point_queue[0].column << endl;\n\n        if ( IsValidCoordinate({point_queue[0].row - 1, point_queue[0].column}) )\n        {\n            if ( point_set.find(make_pair(point_queue[0].row - 1, point_queue[0].column)) == point_set.end() )\n            {\n                point_queue.push_back({point_queue[0].row - 1, point_queue[0].column});\n                point_set.insert(make_pair(point_queue[0].row - 1, point_queue[0].column));\n            }\n\n            if ( grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles < grid[point_queue[0].row - 1][point_queue[0].column].local_score )///UP\n            {\n                grid[point_queue[0].row - 1][point_queue[0].column].parent = {point_queue[0].row, point_queue[0].column};\n                grid[point_queue[0].row - 1][point_queue[0].column].local_score = grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles;\n                grid[point_queue[0].row - 1][point_queue[0].column].global_score = grid[point_queue[0].row - 1][point_queue[0].column].local_score + HeuristicDistance(point_queue[0].row - 1, point_queue[0].column, goal.row, goal.column);\n            }\n        }\n\n        if ( IsValidCoordinate({point_queue[0].row + 1, point_queue[0].column}) )\n        {\n            if ( point_set.find(make_pair(point_queue[0].row + 1, point_queue[0].column)) == point_set.end() )\n            {\n                point_queue.push_back({point_queue[0].row + 1, point_queue[0].column});\n                point_set.insert(make_pair(point_queue[0].row + 1, point_queue[0].column));\n            }\n\n            if ( grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles < grid[point_queue[0].row + 1][point_queue[0].column].local_score )///DOWN\n            {\n                grid[point_queue[0].row + 1][point_queue[0].column].parent = {point_queue[0].row, point_queue[0].column};\n                grid[point_queue[0].row + 1][point_queue[0].column].local_score = grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles;\n                grid[point_queue[0].row + 1][point_queue[0].column].global_score = grid[point_queue[0].row + 1][point_queue[0].column].local_score + HeuristicDistance(point_queue[0].row + 1, point_queue[0].column, goal.row, goal.column);\n            }\n        }\n\n        if ( IsValidCoordinate({point_queue[0].row, point_queue[0].column - 1}) )\n        {\n            if ( point_set.find(make_pair(point_queue[0].row, point_queue[0].column - 1)) == point_set.end() )\n            {\n                point_queue.push_back({point_queue[0].row, point_queue[0].column - 1});\n                point_set.insert(make_pair(point_queue[0].row, point_queue[0].column - 1));\n            }\n\n            if ( grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles < grid[point_queue[0].row][point_queue[0].column - 1].local_score )///LEFT\n            {\n                grid[point_queue[0].row][point_queue[0].column - 1].parent = {point_queue[0].row, point_queue[0].column};\n                grid[point_queue[0].row][point_queue[0].column - 1].local_score = grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles;\n                grid[point_queue[0].row][point_queue[0].column - 1].global_score = grid[point_queue[0].row][point_queue[0].column - 1].local_score + HeuristicDistance(point_queue[0].row, point_queue[0].column - 1, goal.row, goal.column);\n            }\n        }\n\n        if ( IsValidCoordinate({point_queue[0].row, point_queue[0].column + 1}) )\n        {\n            if ( point_set.find(make_pair(point_queue[0].row, point_queue[0].column + 1)) == point_set.end() )\n            {\n                point_queue.push_back({point_queue[0].row, point_queue[0].column + 1});\n                point_set.insert(make_pair(point_queue[0].row, point_queue[0].column + 1));\n            }\n\n            if ( grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles < grid[point_queue[0].row][point_queue[0].column + 1].local_score )///RIGHT\n            {\n                grid[point_queue[0].row][point_queue[0].column + 1].parent = {point_queue[0].row, point_queue[0].column};\n                grid[point_queue[0].row][point_queue[0].column + 1].local_score = grid[point_queue[0].row][point_queue[0].column].local_score + distance_between_tiles;\n                grid[point_queue[0].row][point_queue[0].column + 1].global_score = grid[point_queue[0].row][point_queue[0].column + 1].local_score + HeuristicDistance(point_queue[0].row, point_queue[0].column + 1, goal.row, goal.column);\n            }\n        }\n\n        if ( point_queue.size() > 0 )\n        {\n            point_queue.erase(point_queue.begin() + 0);\n        }\n\n        if ( point_queue.size() > 1 )\n        {\n            for ( int i = 0; i < point_queue.size() - 1; i ++ )\n            {\n                for ( int j = i + 1; j < point_queue.size(); j ++ )\n                {\n                    if ( grid[point_queue[i].row][point_queue[i].column].global_score > grid[point_queue[j].row][point_queue[j].column].global_score )\n                    {\n                        swap(point_queue[i], point_queue[j]);\n                    }\n                }\n            }\n        }\n    }\n\n    //OutputGrid(grid);\n\n    set <pair <int, int>> backtrack_point_set;\n\n    backtrack_point_set.insert(make_pair(goal.row, goal.column));\n\n    coordinate backtrack_point;\n\n    backtrack_point.row = goal.row;\n    backtrack_point.column = goal.column;\n\n    int move_counter = 0;\n\n    while ( backtrack_point.row != start.row || backtrack_point.column != start.column )\n    {\n        //cout << setw(5) << backtrack_point.row << \", \" << backtrack_point.column << \" ---> \";\n\n        backtrack_point = grid[backtrack_point.row][backtrack_point.column].parent;\n\n        backtrack_point_set.insert(make_pair(backtrack_point.row, backtrack_point.column));\n\n        move_counter ++;\n    }\n\n    //cout << setw(5) << start.row << \", \" << start.column << endl;\n\n    cout << endl << \"Moves: \" << move_counter << endl << endl;\n\n    /*COLORING*/\n\n    HANDLE  hConsole;\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    for ( int i = 0; i < rows; i ++ )\n    {\n        for ( int j = 0; j < columns; j ++ )\n        {\n            if ( i == start.row && j == start.column )\n            {\n                FlushConsoleInputBuffer(hConsole);\n                SetConsoleTextAttribute(hConsole, output_start_color);\n\n                //cout << setw(output_setw_value) << \"S\";\n                cout << setw(output_setw_value) << \" \";\n\n                SetConsoleTextAttribute(hConsole, 15);\n            }\n            else if ( i == goal.row && j == goal.column )\n            {\n                FlushConsoleInputBuffer(hConsole);\n                SetConsoleTextAttribute(hConsole, output_goal_color);\n\n                //cout << setw(output_setw_value) << \"G\";\n                cout << setw(output_setw_value) << \" \";\n\n                SetConsoleTextAttribute(hConsole, 15);\n            }\n            else if ( object_point_set.find(make_pair(i, j)) != object_point_set.end() )\n            {\n                FlushConsoleInputBuffer(hConsole);\n                SetConsoleTextAttribute(hConsole, output_object_color);\n\n                //cout << setw(output_setw_value) << output_object_character;\n                cout << setw(output_setw_value) << \" \";\n\n                SetConsoleTextAttribute(hConsole, 15);\n            }\n            else if ( backtrack_point_set.find(make_pair(i, j)) == backtrack_point_set.end() )\n            {\n                FlushConsoleInputBuffer(hConsole);\n                SetConsoleTextAttribute(hConsole, output_space_color);\n\n                //cout << setw(output_setw_value) << \".\";\n                cout << setw(output_setw_value) << \" \";\n\n                SetConsoleTextAttribute(hConsole, 15);\n            }else\n            {\n                FlushConsoleInputBuffer(hConsole);\n                SetConsoleTextAttribute(hConsole, output_road_color);\n\n                //cout << setw(output_setw_value) << \"*\";\n                cout << setw(output_setw_value) << \" \";\n\n                SetConsoleTextAttribute(hConsole, 15);\n            }\n        }\n\n        cout << endl;\n    }\n}\n",
            "runtime": "O(b<sup>d</sup>)",
            "detailed_information": "Az A* algoritmus egy mesterséges intelligencia algoritmus, amelyet leginkább útvonaltervezésre vagy útkeresésre alkalmaznak gráf alapú problémákban.\nAz A* algoritmus hatékonyan találja meg a legrövidebb vagy legoptimálisabb utat egy adott kiindulópont és célállomás között egy súlyozott gráfban vagy térképen.\nFontos megjegyezni, hogy az A* algoritmus hatékonysága és teljesítménye nagymértékben függ a becsült távolságfüggvény (heurisztika) pontosságától.\nRosszul kiválasztott vagy rosszul alkalmazott heurisztikák esetén az algoritmus nem biztosítja a legrövidebb vagy legoptimálisabb utat.\nAz algoritmus komplexitása miatt fontos megfelelően megtervezni és finomhangolni a heurisztikákat az adott alkalmazásra vagy problémára."
        },
        {
            "id": 10,
            "code_id": 10,
            "name": "Futáshossz-kódolás",
            "category": "Tömörítő algoritmus",
            "description": "A futáshossz-kódolás egy nagyon egyszerű tömörítési eljárás, mely a gyakori karakterláncokat helyettesíti kisebb kódokkal.",
            "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring RLE_kodolas(const string& eredeti)\n{\n    string kódolt = \"\";\n\n    int hossz = eredeti.length();\n    int szamlalo = 1;\n\n    for ( int i = 0; i < hossz; i ++ )\n    {\n        if ( i + 1 < hossz && eredeti[i] == eredeti[i + 1] )\n        {\n            szamlalo++;\n        }\n        else\n        {\n            kódolt += to_string(szamlalo) + eredeti[i];\n            szamlalo = 1;\n        }\n    }\n\n    return kódolt;\n}\n\nint main()\n{\n    //Futáshossz-kódolás\n    \n    string eredeti;\n    \n    cout << \"Kérem, adja meg az eredeti szöveget: \";\n    \n    getline(cin, eredeti);\n\n    string kodolt = RLE_kodolas(eredeti);\n\n    cout << \"A futáshossz-kódolt szöveg: \" << kodolt << endl;\n\n    return 0;\n}\n",
            "runtime": "O(N)",
            "detailed_information": "A futáshossz-kódolás (run-length encoding, RLE) egy olyan egyszerű tömörítési eljárás, amely a gyakori karakterláncokat helyettesíti kisebb kódokkal.\nAz RLE az egyik legegyszerűbb tömörítési technika, amely hatékonyan tömöríti az ismétlődő mintázatokat vagy karaktereket egy adatsorban vagy fájlban.\nAz RLE hatékonyan működik olyan adatokon, amelyek ismétlődő vagy nagy egybefüggő blokkokat tartalmaznak, például monokróm képekben vagy egyszerű szöveges fájlokban.\nFontos azonban megjegyezni, hogy az RLE nem mindig hatékony olyan adatok esetén, amelyek kevés ismétlődő mintázatot vagy nagyon változatos adatokat tartalmaznak."
        },
        {
            "id": 11,
            "code_id": 11,
            "name": "Euklideszi algoritmus",
            "category": "Matematikai algoritmus",
            "description": "Az euklideszi algoritmus egy számelméleti algoritmus, amellyel két szám legnagyobb közös osztója határozható meg.",
            "code": "#include <iostream>\n\nusing namespace std;\n\nint legnagyobbKozosOszto(int a, int b)\n{\n    while ( b != 0 )\n    {\n        int maradek = a % b;\n        a = b;\n        b = maradek;\n    }\n    \n    return a;\n}\n\nint main()\n{\n    //Euklideszi algoritmus\n    \n    int szam1, szam2;\n    \n    cout << \"Kérem, adja meg az első számot: \";\n    \n    cin >> szam1;\n    \n    cout << \"Kérem, adja meg a második számot: \";\n    \n    cin >> szam2;\n\n    int legnagyobb_kozos_oszto = legnagyobbKozosOszto(szam1, szam2);\n\n    cout << \"A két szám legnagyobb közös osztója: \" << legnagyobb_kozos_oszto << endl;\n\n    return 0;\n}\n",
            "runtime": "O(log(min(a, b))",
            "detailed_information": "Az Euklideszi algoritmus egy ősi módszer, amelyet két egész szám legnagyobb közös osztójának (gcd) meghatározására használnak.\nEz az algoritmus egyszerű és hatékony módszer a legnagyobb közös osztó kiszámítására, és széles körben alkalmazzák matematikai és számítástechnikai alkalmazásokban.\nAz Euklideszi algoritmus a két számot úgy használja fel, hogy az egyiket a másikkal osztja, majd a maradékot használja fel a következő osztó számként.\nEzt a folyamatot ismételjük, amíg az osztandó szám nem lesz nulla.\nAzt az utolsó nem nulla maradékot kapjuk meg, ami a két eredeti szám legnagyobb közös osztója.\nA könnyű megvalósítás és az alacsony időkomplexitás miatt ez az algoritmus széles körben alkalmazható különböző matematikai és számítástechnikai problémákban."
        }
    ]
}